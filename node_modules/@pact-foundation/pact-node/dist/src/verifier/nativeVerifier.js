"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = void 0;
var ffi = require("ffi-napi");
var path = require("path");
var url = require("url");
var fs = require("fs");
var underscore_1 = require("underscore");
var dll = path.resolve(process.cwd(), 'ffi', 'libpact_verifier_ffi-osx-x86_64.dylib');
var lib = ffi.Library(dll, {
    init: ['string', ['string']],
    version: ['string', []],
    free_string: ['void', ['string']],
    verify: ['int', ['string']],
});
var fileType = function (uri) {
    if (/https?:/.test(url.parse(uri).protocol || '')) {
        return 'URL';
    }
    try {
        if (fs.statSync(path.normalize(uri)).isDirectory()) {
            return 'DIRECTORY';
        }
        else {
            return 'FILE';
        }
    }
    catch (e) {
        throw new Error("Pact file or directory '" + uri + "' doesn't exist");
    }
};
var verify = function (opts) {
    return new Promise(function (resolve, reject) {
        lib.init('LOG_LEVEL');
        console.log(JSON.stringify(opts));
        var mappedArgs = [];
        var arg = function (name, val) {
            if (val) {
                mappedArgs.push(name, val);
            }
        };
        arg('--provider-name', opts.provider);
        arg('--state-change-url', opts.providerStatesSetupUrl);
        arg('--loglevel', opts.logLevel ? opts.logLevel.toLocaleLowerCase() : undefined);
        var u = url.parse(opts.providerBaseUrl);
        arg('--port', u.port);
        arg('--hostname', u.hostname);
        arg('--broker-url', opts.pactBrokerUrl);
        arg('--user', opts.pactBrokerUsername);
        arg('--password', opts.pactBrokerPassword);
        arg('--provider-version', opts.providerVersion);
        arg('--broker-token', opts.pactBrokerToken);
        if (opts.publishVerificationResult) {
            mappedArgs.push('--publish');
        }
        if (opts.enablePending) {
            mappedArgs.push('--enable-pending');
        }
        if (opts.consumerVersionTags && opts.consumerVersionTags.length !== 0) {
            mappedArgs.push('--consumer-version-tags');
            mappedArgs.push(underscore_1.flatten([opts.consumerVersionTags]).join(','));
        }
        if (opts.providerVersionTags && opts.providerVersionTags.length !== 0) {
            mappedArgs.push('--provider-version-tags');
            mappedArgs.push(underscore_1.flatten([opts.providerVersionTags]).join(','));
        }
        if (opts.pactUrls) {
            mappedArgs.push.apply(mappedArgs, opts.pactUrls.reduce(function (acc, uri) {
                switch (fileType(uri)) {
                    case 'URL':
                        return __spreadArray(__spreadArray([], acc), ['--url', uri]);
                    case 'DIRECTORY':
                        return __spreadArray(__spreadArray([], acc), ['--dir', uri]);
                    case 'FILE':
                        return __spreadArray(__spreadArray([], acc), ['--file', uri]);
                    case 'FILE_NOT_FOUND':
                        throw new Error("Pact file or directory '" + uri + "' doesn't exist");
                    default:
                        return acc;
                }
            }, []));
        }
        var request = mappedArgs.join('\n');
        lib.verify.async(request, function (err, res) {
            console.log('response from verifier', err, res);
            if (err) {
                console.error(err);
                reject(err);
            }
            else {
                if (res === 0) {
                    console.log('Verification successful');
                    resolve("finished: " + res);
                }
                else {
                    console.log('Failed verififcation');
                    reject('Verfication failed');
                }
            }
        });
    });
};
exports.verify = verify;
//# sourceMappingURL=nativeVerifier.js.map